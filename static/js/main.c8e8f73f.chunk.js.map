{"version":3,"sources":["model/worker.ts","components/BlurContainer.tsx","components/SquareButton.tsx","Icons/check.svg","Icons/no-check.svg","Icons/gear.svg","components/camera/Camera.tsx","components/prediction/PredictionEntry.tsx","components/prediction/Prediction.tsx","Icons/gallery.svg","components/staticImage/ImageSelectorButton.tsx","Icons/close.svg","components/staticImage/ImageCloseButton.tsx","components/staticImage/StaticImage.tsx","components/App.tsx","reportWebVitals.ts","index.tsx"],"names":["addMethods","methods","module","exports","w","Worker","name","BlurContainer","additionalClassname","children","className","SquareButton","onClick","setHover","undefined","onMouseEnter","onMouseLeave","Camera","predictCanvas","predictions","useState","devices","setDevices","setDeviceId","useRef","handleDevices","useCallback","mediaDevices","videoDevices","filter","kind","useEffect","navigator","enumerateDevices","then","map","device","key","audio","videoConstraints","deviceId","label","PredictionEntry","confidence","top","style","width","toString","Prediction","sortedPredictions","Object","entries","sort","a","b","slice","id","idx","ImageSelectorButton","setImageFile","imageFile","fileInput","current","value","click","src","gallery","alt","ref","type","accept","onChange","e","files","target","length","display","ImageCloseButton","close","StaticImage","image","canvas","reader","FileReader","onload","img","Image","height","ctx","getContext","drawImage","result","backgroundImage","readAsDataURL","modelWorker","ModelWorker","loadModel","process","App","setPredictions","imageData","getImageData","predict","results","Confidences","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c8e8f73f.chunk.js","sourcesContent":["\n\t\t\t\tvar addMethods = require(\"../../node_modules/workerize-loader/dist/rpc-wrapper.js\")\n\t\t\t\tvar methods = [\"loadModel\",\"disposeModel\",\"predict\"]\n\t\t\t\tmodule.exports = function() {\n\t\t\t\t\tvar w = new Worker(__webpack_public_path__ + \"83c31cb3af07d49a4fef.worker.js\", { name: \"[hash].worker.js\" })\n\t\t\t\t\taddMethods(w, methods)\n\t\t\t\t\t\n\t\t\t\t\treturn w\n\t\t\t\t}\n\t\t\t","import React, {FunctionComponent} from \"react\";\nimport './BlurContainer.css';\n\ntype BlurContainerType = {\n    additionalClassname?: string\n}\n\nconst BlurContainer: FunctionComponent<BlurContainerType> = ({ additionalClassname, children }) => {\n    // simple container with rounded corners and a blurred translucent background\n    let className = \"blur-container\";\n    if (!!additionalClassname) {\n        className = className + ` ${additionalClassname}`;\n    }\n    return (\n        <div className={className}>\n            { children }\n        </div>\n    );\n}\n\nexport default BlurContainer;\n","import React, {FunctionComponent} from \"react\";\nimport BlurContainer from \"./BlurContainer\";\nimport \"./SquareButton.css\";\n\ntype SquareButtonProps = {\n    onClick?: () => void,\n    setHover?: (hovering: boolean) => void\n};\n\nconst SquareButton: FunctionComponent<SquareButtonProps> = ({ onClick, setHover, children }) => {\n    // Square button that is inside the blur container\n    return (\n        <div\n            onClick={onClick ? () => onClick() : undefined}\n            onMouseEnter={setHover ? () => setHover(true) : undefined}\n            onMouseLeave={setHover ? () => setHover(false) : undefined}\n        >\n            <BlurContainer additionalClassname=\"square-button\">\n                { children }\n            </BlurContainer>\n        </div>\n\n    );\n}\n\nexport default SquareButton;\n","export default __webpack_public_path__ + \"static/media/check.06c31cf8.svg\";","export default __webpack_public_path__ + \"static/media/no-check.fe894ae6.svg\";","export default __webpack_public_path__ + \"static/media/gear.b1f1407e.svg\";","import React, {useEffect, useState, useRef, useCallback} from \"react\";\r\nimport Webcam from \"react-webcam\";\r\nimport SourceSelector from \"./SourceSelector\";\r\nimport \"./Camera.css\";\r\n\r\ntype CameraProps = {\r\n    predictCanvas: (canvas: HTMLCanvasElement) => void;\r\n    predictions?: { [label: string]: number };\r\n}\r\n\r\n// Our webcam display and capture component\r\nfunction Camera({ predictCanvas, predictions }: CameraProps) {\r\n    const [devices, setDevices] = useState<MediaDeviceInfo[]>([]);\r\n    const [deviceId, setDeviceId] = useState<string | undefined>(undefined);\r\n    const [imageFlip, setImageFlip] = useState(true);\r\n    const webcamRef = useRef<Webcam>(null);\r\n    const [selectorVisible, setSelectorVisible] = useState(false);\r\n\r\n    // handle any webcam plugged into the computer\r\n    // https://github.com/mozmorris/react-webcam#show-all-cameras-by-deviceid\r\n    const handleDevices = useCallback(\r\n        (mediaDevices: MediaDeviceInfo[]) => {\r\n            // find all the webcams\r\n            const videoDevices = mediaDevices.filter(({kind}) => kind === \"videoinput\");\r\n            setDevices(videoDevices);\r\n            // set our initial webcam to be the first in the list\r\n            //if (videoDevices.length > 0) {\r\n              //  setDeviceId(videoDevices[0].deviceId);\r\n            //}\r\n        },[setDevices, setDeviceId]\r\n    );\r\n    useEffect(() => {\r\n        navigator.mediaDevices.enumerateDevices().then(handleDevices);\r\n    }, [handleDevices]);\r\n    \r\n                \r\n\r\n    \r\n    return (\r\n        <>\r\n          {devices.map((device, key) => (\r\n              <div>\r\n                <Webcam audio={false} videoConstraints={{ deviceId: device.deviceId }} />\r\n                {device.label || `Device ${key + 1}`}\r\n              </div>\r\n    \r\n            ))}\r\n        </>\r\n      );\r\n    \r\n    // function to grab the current frame drawn on canvas from the webcam\r\n    const getCanvas: () => Promise<HTMLCanvasElement | undefined> = useCallback(async () => {\r\n        let newImage;\r\n        if (webcamRef.current) {\r\n            newImage = webcamRef.current.getCanvas();\r\n            if (newImage) {\r\n                return newImage;\r\n            }\r\n        }\r\n    }, [webcamRef]);\r\n\r\n    // helper for waiting in our loop when the camera is loading (getting the image)\r\n    const sleep = useCallback((ms: number) => {\r\n        return new Promise<NodeJS.Timeout>(function (resolve, reject) {\r\n            setTimeout(resolve, ms);\r\n        });\r\n    }, []);\r\n\r\n    // while we have the webcam mounted, predict frames as fast as we get new predictions back from the model\r\n    useEffect(() => {\r\n        getCanvas().then(async (canvas: HTMLCanvasElement | undefined) => {\r\n            let currentCanvas = canvas;\r\n            while (!currentCanvas) {\r\n                // if no canvas, wait 500ms and try again\r\n                await sleep(500);\r\n                currentCanvas = await getCanvas();\r\n            }\r\n            if (currentCanvas) {\r\n                predictCanvas(currentCanvas);\r\n            }\r\n        })\r\n    }, [sleep, predictions, deviceId, getCanvas, predictCanvas])\r\n\r\n    return (\r\n        <div id=\"video-container\" onClick={() => setSelectorVisible(false)}>\r\n            <SourceSelector\r\n                devices={devices}\r\n                deviceId={deviceId}\r\n                setDeviceId={setDeviceId}\r\n                imageFlip={imageFlip}\r\n                setImageFlip={setImageFlip}\r\n                selectorVisible={selectorVisible}\r\n                setSelectorVisible={setSelectorVisible}\r\n            />\r\n            <Webcam\r\n                ref={webcamRef}\r\n                screenshotFormat=\"image/jpeg\"\r\n                forceScreenshotSourceSize={true}\r\n                screenshotQuality={1}\r\n                audio={false}\r\n                videoConstraints={{\r\n                    width: {ideal: 1920},\r\n                    height: {ideal: 1080},\r\n                    deviceId: !!deviceId ? {exact: deviceId} : undefined\r\n                }}\r\n                mirrored={imageFlip}\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Camera;\r\n","import React from \"react\";\nimport \"./PredictionEntry.css\";\n\ntype PredictionEntryProps = {\n    label: string\n    confidence?: number\n    top?: boolean\n}\n\nfunction PredictionEntry({label, confidence, top}: PredictionEntryProps) {\n    // render the predicted label and a bar representing the confidence value\n    // make the top confidence value green\n    return (\n        <div key={label} className=\"prediction-entry\">\n            {label}\n            {!!confidence ?\n                <div\n                    className={\"prediction-bar\" + (top ? \" prediction-green\" : \"\")}\n                    style={{width: (confidence*100).toString() + \"%\"}}\n                />\n            : null}\n        </div>\n    );\n}\n\nexport default PredictionEntry;\n","import React from \"react\";\nimport BlurContainer from \"../BlurContainer\";\nimport PredictionEntry from \"./PredictionEntry\";\nimport \"./Prediction.css\";\n\ntype PredictionProps = {\n    predictions?: { [label: string]: number },\n    top?: number\n}\n\nfunction Prediction({predictions, top=3}: PredictionProps) {\n    // display the top N (default 3) predictions returned from the model\n    let sortedPredictions: Array<[string, number]> | undefined;\n    if (!!predictions) {\n        // sort our predictions by the confidence value and take the top N\n        sortedPredictions = Object.entries(predictions)\n            .sort((a, b) => b[1] - a[1])\n            .slice(0, top);\n    }\n    return (\n        <div id=\"predictions\">\n            <BlurContainer additionalClassname=\"prediction-container\">\n                {!!sortedPredictions ?\n                    sortedPredictions.map(([label, confidence], idx) => (\n                        <PredictionEntry key={label} label={label} confidence={confidence} top={idx===0} />\n                    ))\n                    : <PredictionEntry label={'Loading...'} />\n                }\n            </BlurContainer>\n        </div>\n    );\n}\n\nexport default Prediction;\n","export default __webpack_public_path__ + \"static/media/gallery.45752e9c.svg\";","import React, {useEffect, useRef} from \"react\";\nimport SquareButton from \"../SquareButton\";\nimport gallery from \"../../Icons/gallery.svg\";\n\nimport \"./ImageSelectorButton.css\";\n\ntype ImageSelectorButtonProps = {\n    setImageFile: (image: File | null) => void;\n    imageFile: File | null;\n};\n\n// Component for selecting an image file for prediction\nfunction ImageSelectorButton({setImageFile, imageFile}: ImageSelectorButtonProps) {\n    // ref to the hidden file input element\n    const fileInput = useRef<HTMLInputElement>(null);\n\n    // if we have a null file (from clearing the image), clear the file input value\n    useEffect(\n        () => {\n            if (!imageFile && fileInput.current) {\n                fileInput.current.value = \"\";\n            }\n        },\n        [imageFile, fileInput]\n    )\n\n    // make an onclick that will open the file dialog\n    const onClick = () => {\n        if (fileInput.current) {\n            fileInput.current.click();\n        }\n    }\n\n    // set our image file from the picker\n    const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n        const files = e.target.files;\n        if (files && files.length > 0) {\n            setImageFile(files[0]);\n        }\n    }\n\n    return (\n        <div\n            id=\"image-select-button\"\n            onClick={onClick}\n        >\n            <SquareButton>\n                <img id=\"gallery-icon\" src={gallery} alt={\"File Selector\"} />\n            </SquareButton>\n            <input ref={fileInput} type=\"file\" accept=\"image/*\" onChange={onChange} style={{display: \"none\"}} />\n        </div>\n    )\n}\n\nexport default ImageSelectorButton;\n","export default __webpack_public_path__ + \"static/media/close.b502d4ba.svg\";","import React from \"react\";\nimport SquareButton from \"../SquareButton\";\nimport close from \"../../Icons/close.svg\";\n\nimport \"./ImageCloseButton.css\";\n\ntype ImageCloseButtonProps = {\n    setImageFile: (image: File | null) => void;\n};\n\n// Component for clearing the static image and going back to the webcam view\nfunction ImageCloseButton({setImageFile}: ImageCloseButtonProps) {\n    \n    const onClick = () => {\n        setImageFile(null);\n    };\n\n    return (\n        <div id=\"image-close-button\">\n            <SquareButton onClick={onClick}>\n                <img id=\"close-icon\" src={close} alt={\"Close\"} />\n            </SquareButton>\n        </div>\n    )\n}\n\nexport default ImageCloseButton;\n","import React, {useEffect, useRef} from \"react\";\nimport ImageCloseButton from \"./ImageCloseButton\";\n\nimport \"./StaticImage.css\";\n\ntype StaticImageProps = {\n    predictCanvas: (canvas: HTMLCanvasElement) => void;\n    image: File;\n    setImageFile: (image: File | null) => void;\n}\n\n// Component for displaying our selected image file for prediction\nfunction StaticImage({ predictCanvas, image, setImageFile }: StaticImageProps) {\n    // display our image file on a canvas and call the predict function with that canvas\n    const canvas = useRef<HTMLCanvasElement>(null);\n    const display = useRef<HTMLDivElement>(null);\n\n    useEffect(() => {\n        const reader = new FileReader();\n        reader.onload = (e) => {\n            // make an image to draw on the canvas\n            const img = new Image();\n            img.onload = () => {\n                if (canvas.current) {\n                    // draw the image on our canvas\n                    canvas.current.width = img.width;\n                    canvas.current.height = img.height;\n                    const ctx = canvas.current.getContext(\"2d\");\n                    if (!!ctx) {\n                        // draw our image on the context\n                        ctx.drawImage(img,0,0);\n                        // drawing is finished, run the prediction!\n                        predictCanvas(canvas.current);\n                    }\n                }\n            }\n\n            // load the image from our reader\n            if (e.target) {\n                img.src = e.target.result as string;\n                if (display.current) {\n                    display.current.style.backgroundImage = `url(${e.target.result})`;\n                }\n            }\n        }\n        // read our image file and process it!\n        reader.readAsDataURL(image);\n    }, [image, predictCanvas, display]);\n\n    return (\n        <div id=\"static-image\" ref={display}>\n            <ImageCloseButton setImageFile={setImageFile} />\n            <canvas ref={canvas} style={{display: \"none\"}} />\n        </div>\n    )\n}\n\nexport default StaticImage;\n","import React, {useCallback, useState} from 'react';\nimport Camera from './camera/Camera';\nimport Prediction from './prediction/Prediction';\nimport ImageSelectorButton from './staticImage/ImageSelectorButton';\nimport StaticImage from './staticImage/StaticImage';\n\n// @ts-ignore\n// eslint-disable-next-line import/no-webpack-loader-syntax\nimport ModelWorker from \"workerize-loader!../model/worker\";\n\n// create our web worker instance for running the tfjs model without blocking the UI thread\nconst modelWorker = ModelWorker();\n// the filepaths to our exported signature.json and model.json files (in the public/model folder)\nconst signatureFile = process.env.PUBLIC_URL + `/model/signature.json`;\nconst modelFile = process.env.PUBLIC_URL + `/model/model.json`;\n// load our model in the web worker\nmodelWorker.loadModel(signatureFile, modelFile);\n\n\nfunction App() {\n    // state for keeping track of our predictions -- map of {label: confidence} from running the model on an image\n    const [predictions, setPredictions] = useState<{[key: string]: number} | undefined>(undefined);\n    // state for using a static image from file picker\n    const [imageFile, setImageFile] = useState<File | null>(null);\n\n    // function to run the image from an html canvas element through our model\n    const predictCanvas = useCallback((canvas: HTMLCanvasElement) => {\n        // get the canvas context\n        const ctx = canvas.getContext('2d');\n        if (ctx) {\n            // get the pixel data from the full canvas\n            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n            // run the async predict function and set the values to our state\n            modelWorker.predict(imageData).then((results: {Confidences: {[label: string]: number}}) => {\n                if (results) {\n                    setPredictions(results.Confidences);\n                }\n            });\n        }\n    }, []);\n\n    return (\n        <div>\n            <ImageSelectorButton setImageFile={setImageFile} imageFile={imageFile} />\n            {\n                !imageFile ? \n                <Camera predictCanvas={predictCanvas} predictions={predictions} /> :\n                <StaticImage predictCanvas={predictCanvas} image={imageFile} setImageFile={setImageFile} />\n            }\n            <Prediction predictions={predictions}/>\n        </div>\n    );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}